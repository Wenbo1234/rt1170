/*
 * Copyright 2019 NXP
 * All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/***********************************************************************************************************************
 * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
 * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
 **********************************************************************************************************************/

/*
 * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
!!GlobalInfo
product: Pins v7.0
processor: MIMXRT1176xxxxx
package_id: MIMXRT1176DVMAA
mcu_data: ksdk2_0
processor_version: 0.0.2
 * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
 */   
#include "fsl_common.h"
#include "fsl_iomuxc.h"
#include "fsl_sai_edma.h"   
#include "fsl_dmamux.h"
#include "fsl_gpio.h"
#include "audio.h"
#include "music.h"
/*******************************************************************************
 * Prototypes
 ******************************************************************************/
static void codec_callback(I2S_Type *base, sai_edma_handle_t *handle, status_t status, void *userData);
static void mqs_callback(I2S_Type *base, sai_edma_handle_t *handle, status_t status, void *userData);
/*******************************************************************************
 * Variables
 ******************************************************************************/   
uint32_t Audio_Target_Address;
uint32_t Audio_Target_Length;   
uint32_t *p;
uint32_t Music_Length[] =
{
    0x0005F720, 0x00158060, 0x00081320, 0x00055EE0, 0x000561E0, 0x0000ED60, 0x000222E0, 0x000384E0, 
    0x00081360, 0x000AC440, 0x002F1880, 0x0005DBE0, 0x0001D4C0, 0x0001C160, 0x00025C20, 0x0002BDE0,
};

uint32_t Music_Offset[] =
{
    0x00000000, 0x0005F720, 0x001B7780, 0x00238AA0, 0x0028E980, 0x002E4B60, 0x002F38C0, 0x00315BA0, 
    0x0034E080, 0x003CF3E0, 0x0047B820, 0x0076D0A0, 0x007CAC80, 0x007E8140, 0x008042A0, 0x00829EC0,
};

const clock_audio_pll_config_t audioPllConfig = {
    .loopDivider = 32,  /* PLL loop divider. Valid range for DIV_SELECT divider value: 27~54. */
    .postDivider = 1,   /* Divider after the PLL, should only be 1, 2, 4, 8, 16. */
    .numerator   = 77,  /* 30 bit numerator of fractional loop divider. */
    .denominator = 100, /* 30 bit denominator of fractional loop divider */   
};

AT_NONCACHEABLE_SECTION_INIT(sai_edma_handle_t txHandle) = {0};
edma_handle_t dmaHandle                                  = {0};
AT_NONCACHEABLE_SECTION_ALIGN(static uint8_t buffer[BUFFER_NUM * BUFFER_SIZE], 4);
volatile uint32_t finishIndex = 0U;
volatile uint32_t emptyBlock  = BUFFER_NUM;

sai_transfer_t xfer;
uint32_t cpy_index = 0U, tx_index = 0U;

static void BOARD_Init_Codec_Pin(void){
  CLOCK_EnableClock(kCLOCK_Iomuxc); 
  
  IOMUXC_SetPinMux(
      IOMUXC_GPIO_AD_17_SAI1_MCLK,            /* GPIO_AD_17 is configured as SAI1_MCLK */
      1U);                                    /* Software Input On Field: Force input path of pad GPIO_AD_17 */
  IOMUXC_SetPinMux(
      IOMUXC_GPIO_AD_21_SAI1_TX_DATA00,       /* GPIO_AD_21 is configured as SAI1_TX_DATA00 */
      1U);                                    /* Software Input On Field: Force input path of pad GPIO_AD_21 */
  IOMUXC_SetPinMux(
      IOMUXC_GPIO_AD_22_SAI1_TX_BCLK,         /* GPIO_AD_22 is configured as SAI1_TX_BCLK */
      1U);                                    /* Software Input On Field: Force input path of pad GPIO_AD_22 */
  IOMUXC_SetPinMux(
      IOMUXC_GPIO_AD_23_SAI1_TX_SYNC,         /* GPIO_AD_23 is configured as SAI1_TX_SYNC */
      1U); 
  
   IOMUXC_SetPinConfig(
      IOMUXC_GPIO_AD_17_SAI1_MCLK,            /* GPIO_AD_17 PAD functional properties : */
      0x02U);                                 /* Slew Rate Field: Slow Slew Rate
                                                 Drive Strength Field: high driver
                                                 Pull / Keep Select Field: Pull Disable, Highz
                                                 Pull Up / Down Config. Field: Weak pull down
                                                 Open Drain Field: Disabled */
  IOMUXC_SetPinConfig(
      IOMUXC_GPIO_AD_21_SAI1_TX_DATA00,       /* GPIO_AD_21 PAD functional properties : */
      0x02U);                                 /* Slew Rate Field: Slow Slew Rate
                                                 Drive Strength Field: high driver
                                                 Pull / Keep Select Field: Pull Disable, Highz
                                                 Pull Up / Down Config. Field: Weak pull down
                                                 Open Drain Field: Disabled */
  IOMUXC_SetPinConfig(
      IOMUXC_GPIO_AD_22_SAI1_TX_BCLK,         /* GPIO_AD_22 PAD functional properties : */
      0x02U);                                 /* Slew Rate Field: Slow Slew Rate
                                                 Drive Strength Field: high driver
                                                 Pull / Keep Select Field: Pull Disable, Highz
                                                 Pull Up / Down Config. Field: Weak pull down
                                                 Open Drain Field: Disabled */
  IOMUXC_SetPinConfig(
      IOMUXC_GPIO_AD_23_SAI1_TX_SYNC,         /* GPIO_AD_23 PAD functional properties : */
      0x02U);                                 /* Slew Rate Field: Slow Slew Rate
                                                 Drive Strength Field: high driver
                                                 Pull / Keep Select Field: Pull Disable, Highz
                                                 Pull Up / Down Config. Field: Weak pull down
                                                 Open Drain Field: Disabled */
}

static void BOARD_Init_MQS_Pin(void){
  CLOCK_EnableClock(kCLOCK_Iomuxc); 
  
  IOMUXC_SetPinMux(
      IOMUXC_GPIO_LPSR_02_MQS_RIGHT,         
      1U);    
  IOMUXC_SetPinMux(
      IOMUXC_GPIO_LPSR_03_MQS_LEFT,         
      1U);   
  IOMUXC_SetPinMux(
      IOMUXC_GPIO_AD_12_GPIO9_IO11,         
      1U);    
 
  IOMUXC_SetPinConfig(
      IOMUXC_GPIO_LPSR_02_MQS_RIGHT,            
      0x02U);  
  IOMUXC_SetPinConfig(
      IOMUXC_GPIO_LPSR_03_MQS_LEFT,            
      0x02U); 
  IOMUXC_SetPinConfig(
      IOMUXC_GPIO_AD_12_GPIO9_IO11,            
      0x02U); 
}

static void BOARD_EnableSai1MclkOutput(bool enable)
{
    if (enable)
    {
        IOMUXC_GPR->GPR0 |= IOMUXC_GPR_GPR0_SAI1_MCLK_DIR_MASK;
    }
    else
    {
        IOMUXC_GPR->GPR0 &= (~IOMUXC_GPR_GPR0_SAI1_MCLK_DIR_MASK);
    }
}

void Codec_InitHardware(void)
{
    BOARD_Init_Codec_Pin();
}

void MQS_InitHardware(void)
{
    gpio_pin_config_t mqs_amp_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
    BOARD_Init_MQS_Pin();
    GPIO_PinInit(GPIO9, 11U, &mqs_amp_config);
    /*Enabe NVC2211*/
    GPIO_PinWrite(GPIO9, 11U, 1U);
}

void Codec_InitClock(void)
{
    CLOCK_InitAudioPll(&audioPllConfig);
    /*Clock setting for SAI1*/
    CLOCK_SetRootClockMux(kCLOCK_Root_Sai1, 4);       
    CLOCK_SetRootClockDiv(kCLOCK_Root_Sai1, DEMO_SAI1_CLOCK_SOURCE_DIVIDER); 
    /*Enable MCLK clock*/
    BOARD_EnableSai1MclkOutput(true);
}

void MQS_InitClock(void)
{
    CLOCK_InitAudioPll(&audioPllConfig);
    /*Clock setting for SAI3*/
    CLOCK_SetRootClockMux(kCLOCK_Root_Sai3, 4);       
    CLOCK_SetRootClockDiv(kCLOCK_Root_Sai3, DEMO_SAI3_CLOCK_SOURCE_DIVIDER); 

    CLOCK_SetRootClockMux(kCLOCK_Root_Mqs, 6); 
    CLOCK_SetRootClockDiv(kCLOCK_Root_Mqs, DEMO_MQS_CLOCK_SOURCE_DIVIDER);   
    /*Enable MQS clock*/
    CLOCK_EnableClock(kCLOCK_Mqs);
}

void Codec_InitSAI(void)
{
    edma_config_t dmaConfig = {0};
    sai_transceiver_t config;
    sai_config_t sai_format;
  
    EDMA_GetDefaultConfig(&dmaConfig);
    EDMA_Init(EXAMPLE_DMA, &dmaConfig);
    EDMA_CreateHandle(&dmaHandle, EXAMPLE_DMA, CODEC_CHANNEL);

    DMAMUX_Init(DMAMUX0);
    DMAMUX_SetSource(DMAMUX0, CODEC_CHANNEL, EXAMPLE_SAI1_TX_SOURCE);
    DMAMUX_EnableChannel(DMAMUX0, CODEC_CHANNEL);

    /* SAI init */
    SAI_Init(Codec_SAI);  
    
    SAI_TxGetDefaultConfig(&sai_format);

    SAI_TxInit(Codec_SAI, &sai_format);
    
    SAI_TransferTxCreateHandleEDMA(Codec_SAI, &txHandle, codec_callback, NULL, &dmaHandle);

    /* I2S mode configurations */
    SAI_GetClassicI2SConfig(&config, DEMO_AUDIO_BIT_WIDTH, kSAI_Stereo, kSAI_Channel0Mask);
    
    SAI_TransferTxSetConfigEDMA(Codec_SAI, &txHandle, &config);
    
    /* set bit clock divider */  // 24576000U, 48000 16 2  BCLK 1.536MHz      22579200 44100 16 2       
    SAI_TxSetBitClockRate(Codec_SAI, DEMO_CODEC_MASTER_CLOCK, DEMO_AUDIO_SAMPLE_RATE, DEMO_AUDIO_BIT_WIDTH, DEMO_AUDIO_DATA_CHANNEL);      
}

void MQS_Init(void)
{
    edma_config_t dmaConfig = {0};
    sai_transceiver_t config;
    sai_config_t sai_format;
  
    EDMA_GetDefaultConfig(&dmaConfig);
    EDMA_Init(EXAMPLE_DMA, &dmaConfig);
    EDMA_CreateHandle(&dmaHandle, EXAMPLE_DMA, MQS_CHANNEL);

    DMAMUX_Init(DMAMUX0);
    DMAMUX_SetSource(DMAMUX0, MQS_CHANNEL, EXAMPLE_SAI3_TX_SOURCE);
    DMAMUX_EnableChannel(DMAMUX0, MQS_CHANNEL);

    /* SAI init */
    SAI_Init(MQS_SAI);  
    
    SAI_TxGetDefaultConfig(&sai_format);
    
    SAI_TxInit(MQS_SAI, &sai_format);
    
    SAI_TransferTxCreateHandleEDMA(MQS_SAI, &txHandle, mqs_callback, NULL, &dmaHandle);

    /* I2S mode configurations */
    SAI_GetLeftJustifiedConfig(&config, DEMO_AUDIO_BIT_WIDTH, kSAI_Stereo, kSAI_Channel0Mask);
    
    SAI_TransferTxSetConfigEDMA(MQS_SAI, &txHandle, &config);
    
    /* set bit clock divider */  // 24576000U, 48000 16 2  BCLK 1.536MHz      22579200 44100 16 2       
    SAI_TxSetBitClockRate(MQS_SAI, DEMO_MQS_MASTER_CLOCK, DEMO_AUDIO_SAMPLE_RATE, DEMO_AUDIO_BIT_WIDTH, DEMO_AUDIO_DATA_CHANNEL);      
     
/* Enable MQS and set MQS clock divider */
    IOMUXC_MQSEnterSoftwareReset(MQS_IOMUXC, true);
    IOMUXC_MQSEnterSoftwareReset(MQS_IOMUXC, false);
    IOMUXC_MQSConfig(MQS_IOMUXC, kIOMUXC_MqsPwmOverSampleRate64,1-1);//DEMO_MQS_CLK_FREQ/64/48000/2/16-1
    IOMUXC_MQSEnable(MQS_IOMUXC, true);
}

void Codec_DeInitSAI(void)
{
    SAI_TransferAbortSendEDMA(Codec_SAI, &txHandle);
    DMAMUX_Deinit(DMAMUX0);
    SAI_Deinit(Codec_SAI);
    IOMUXC_MQSEnable(MQS_IOMUXC, false);
}

void MQS_DeInitSAI(void)
{
    SAI_TransferAbortSendEDMA(MQS_SAI, &txHandle);
    DMAMUX_Deinit(DMAMUX0);
    SAI_Deinit(MQS_SAI);
}

static void codec_callback(I2S_Type *base, sai_edma_handle_t *handle, status_t status, void *userData)
{
    if (kStatus_SAI_RxError == status)
    {
    }
    else
    {
        cpy_index++;
        if(cpy_index >= Audio_Target_Length / BUFFER_SIZE)
        {
          cpy_index =0;
        }
        memcpy((uint8_t *)&buffer[BUFFER_SIZE * (cpy_index % BUFFER_NUM)], (uint8_t *)&(AUDIO_OFFSET + Audio_Target_Address)[cpy_index * BUFFER_SIZE], sizeof(uint8_t) * BUFFER_SIZE);
        xfer.data     = (uint8_t *)&buffer[BUFFER_SIZE * (tx_index % BUFFER_NUM)];
        xfer.dataSize = BUFFER_SIZE;
        while(kStatus_Success != SAI_TransferSendEDMA(Codec_SAI, &txHandle, &xfer));
        tx_index = (tx_index+1)%2;
    }
}

static void mqs_callback(I2S_Type *base, sai_edma_handle_t *handle, status_t status, void *userData)
{
    if (kStatus_SAI_RxError == status)
    {
    }
    else
    {
        cpy_index++;
        if(cpy_index >= Audio_Target_Length / BUFFER_SIZE)
        {
          cpy_index =0;
        }
        memcpy((uint8_t *)&buffer[BUFFER_SIZE * (cpy_index % BUFFER_NUM)], (uint8_t *)&(AUDIO_OFFSET + Audio_Target_Address)[cpy_index * BUFFER_SIZE], sizeof(uint8_t) * BUFFER_SIZE);
        xfer.data     = (uint8_t *)&buffer[BUFFER_SIZE * (tx_index % BUFFER_NUM)];
        xfer.dataSize = BUFFER_SIZE;
        while(kStatus_Success != SAI_TransferSendEDMA(MQS_SAI, &txHandle, &xfer));
        tx_index = (tx_index+1)%2;
    }
}

void Start_PlayBack(audio_select_t select)
{   
    cpy_index = 0;
    tx_index = 0;
    memcpy((uint8_t *)&buffer[BUFFER_SIZE * (cpy_index % BUFFER_NUM)], (uint8_t *)&(AUDIO_OFFSET + Audio_Target_Address)[cpy_index * BUFFER_SIZE], sizeof(uint8_t) * BUFFER_SIZE);
    xfer.data     = (uint8_t *)&buffer[BUFFER_SIZE * (tx_index % BUFFER_NUM)];
    xfer.dataSize = BUFFER_SIZE;
    if(select == CODEC_playback)
    {
        /* Wait for available queue. */
        while(kStatus_Success != SAI_TransferSendEDMA(Codec_SAI, &txHandle, &xfer)); 
    }  
    else if(select == MQS_playback)
    {
        /* Wait for available queue. */
        while(kStatus_Success != SAI_TransferSendEDMA(MQS_SAI, &txHandle, &xfer)); 
    } 
}

void Audio_PlayBack(audio_select_t select, audio_type_t type, audio_play_action_t action)
{
    if(action == kAUDIO_play_stop)
    {
        if(select == CODEC_playback)
        {
            Codec_DeInitSAI();
        }  
        else if(select == MQS_playback)
        {
            MQS_DeInitSAI();
        } 
    }
    else if(action == kAUDIO_play_start)
    {   
        if(select == CODEC_playback)
        {
            Codec_InitSAI();
        }  
        else if(select == MQS_playback)
        {
            MQS_Init();
        } 
        switch (type)
        {
            case kAUDIO_Type_1:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_1];
                Audio_Target_Length = Music_Length[kAUDIO_Type_1];
                break;  
            case kAUDIO_Type_2:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_2];
                Audio_Target_Length = Music_Length[kAUDIO_Type_2];
                break; 
            case kAUDIO_Type_3:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_3];
                Audio_Target_Length = Music_Length[kAUDIO_Type_3];
                break; 
            case kAUDIO_Type_4:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_4];
                Audio_Target_Length = Music_Length[kAUDIO_Type_4];
                break;
            case kAUDIO_Type_5:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_5];
                Audio_Target_Length = Music_Length[kAUDIO_Type_5];
                break; 
            case kAUDIO_Type_6:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_6];
                Audio_Target_Length = Music_Length[kAUDIO_Type_6];
                break;
            case kAUDIO_Type_7:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_7];
                Audio_Target_Length = Music_Length[kAUDIO_Type_7];
                break;
            case kAUDIO_Type_8:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_8];
                Audio_Target_Length = Music_Length[kAUDIO_Type_8];
                break;
            case kAUDIO_Type_9:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_9];
                Audio_Target_Length = Music_Length[kAUDIO_Type_9];
                break;
            case kAUDIO_Type_10:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_10];
                Audio_Target_Length = Music_Length[kAUDIO_Type_10];
                break;
            case kAUDIO_Type_11:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_11];
                Audio_Target_Length = Music_Length[kAUDIO_Type_11];
                break;
            case kAUDIO_Type_12:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_12];
                Audio_Target_Length = Music_Length[kAUDIO_Type_12];
                break;
            case kAUDIO_Type_13:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_13];
                Audio_Target_Length = Music_Length[kAUDIO_Type_13];
                break;
            case kAUDIO_Type_14:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_14];
                Audio_Target_Length = Music_Length[kAUDIO_Type_14];
                break;
            case kAUDIO_Type_15:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_15];
                Audio_Target_Length = Music_Length[kAUDIO_Type_15];
                break;
            case kAUDIO_Type_16:
                Audio_Target_Address = Music_Offset[kAUDIO_Type_16];
                Audio_Target_Length = Music_Length[kAUDIO_Type_16];
                break;              
            default:
                                break;
        }
        Start_PlayBack(select);
    }
}
